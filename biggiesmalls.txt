# include <vector>
# include <chrono>
# include <random>
# include <iostream>
# include <cassert>
# include <exception>
    
using namespace std;
    
// GLOBAL CONSTANTS
    
// declare parameters
const int   deathAge = 1;
const int   N = 20;
const int   S = 100; // m^2
const int   maxTime = 10;
const double beta = 1.0;     // tuning parameter for the effect of size on offsrping production <THEO 13/12>
const double kappa = 2.0;    // basal number of offspring produced when beta = 0 <THEO 13/12>
const double epsilon = 1.0;  // scaling parameter for offsrping production <THEO 13/12>
const double meanSize = 2.0; //added by Raph 12/12
const double stdSize = 3.0;  //added by Raph 12/12
const double minBodySize = 0.1; // added by Raph 12/12, precision threshold to say if a number is equal to zero // min size <THEO 14/12>
const int maxSampling = 1000; // cannot resample the size of an individual more than this number if the size happen to be too small
bernoulli_distribution mutationEvent(0.5); // mutation rate
normal_distribution <double> bodySizeDistribution(meanSize, stdSize); //added by Raph 12/12
normal_distribution <double> mutation(0.0, 0.1); // <THEO 12/12> // distribution mutation steps
// mutation std = 0.5 allows to go from values around 3.0 at gen0 to ~15.0 at gen1000


// RANDOM NUMBER GENERATOR
    
// declare rng
mt19937_64 rng;
    
// CLASSES
    
// declare predators
    
// class of individuals
struct ind {
        double  size = 0; // <THEO 13/12>
        bool    hasFood = false;
        int     age = 0;
    };
    
    // ACCESSORY FUNCTION
    
    // Function to shuffle a vector (added by Raph 12/12)
    void shuffleVector(vector<ind> &vec, mt19937_64 &rng) {
        
        // For each position in the vector (starting from the end)...
        for (int i = vec.size() - 1; i > 0; --i) {
            
            // Create a distribution of random numbers between 0 and i
            uniform_int_distribution<int> randomNumber(0, i);
            
            // Draw a random position placed before it in the vector
            int j = randomNumber(rng);
            assert(j <= i);
            assert(j >= 0);
            
            // Swap the two positions
            ind tmp = vec[i];
            vec[i] = vec[j];
            vec[j] = tmp;
            
        }
        
    }

    // determine the litter size of an individual <THEO 12/12>
    int getNbOffspring(const double &parentSize){
        
        double meanNbOffspring = (beta / parentSize + (1.0 - beta) * kappa) * epsilon;
        
        poisson_distribution<int> offspringDistribution (meanNbOffspring);
        int nbOffspring = offspringDistribution(rng);
        if (nbOffspring > 10)
            nbOffspring = 10;
        return nbOffspring;
    }

    
    // MAIN FUNCTION
    
    int main() {
        
        try {
            //assert( !(alpha < 0) && !(alpha > 1) );
            assert( !(beta < 0) && !(beta > 1) );
            //assert( !(gamma < 0) && !(gamma > 1) );
            
            // Raph 12/12 security check
            if (meanSize <= 0.0)
                throw runtime_error("meanSize cannot be zero or negative");
            if (stdSize <= 0.0)
                throw runtime_error("stdSize cannot be zero or negative");
            if (minBodySize < 0.0)
                throw runtime_error("precision cannot be zero");
            
            // set random seed
            auto tp = chrono::high_resolution_clock::now();
            unsigned seed = static_cast<unsigned>(tp.time_since_epoch().count());
            rng.seed(seed);
            
            // Declare an initial population of N individuals
            vector <ind> population(N);
            assert(population.size() == N);
            
            // Initialize the size of the individuals from a normal distribution with a given mean and standard deviation (Raph 12/12)
            for (int i = 0; i < population.size(); ++i) {
                int a = 0;
                do {
                    population[i].size = bodySizeDistribution(rng);
                    ++a;
                    // If the size of an individual is too small, redraw it (the normal distribution is truncated in zero)
                    // but not too many times
                } while (population[i].size <= minBodySize && a < maxSampling);
                if (population[i].size < minBodySize)
                    throw runtime_error("negative values of body size were generated");
                //cout << population[i].size << ' ';
            }
            //cout << endl;
            
            
            
            // generation step loop
            for(int t = 1; t <= maxTime; ++t) {
                
                // Check if there still are individuals in the population
                if (population.empty()){
                    cerr << "Generation " << t << ": population went extinct\n";
                    exit(EXIT_SUCCESS);
                }
                
                // Declare the number of food patches available as defined by island surface
                // foodPatches is a vector of subvectors: each subvector says which individuals are on the patch
                vector <vector<int> > foodPatches(S);
                assert(foodPatches.size() == S);
                
                // 1 - Predation
                // for each predator {
                //      for x preys {
                //          pick a random prey based on its weight
                //          add preys resource stock to predator stock
                //          ยก remove dead preys ! crematorium.push_back(i) + removal
                
                //      }
                // }
                
                // (Re)Shuffling the population vector
                shuffleVector(population, rng);
                
                /*
                // 2 - Assign individuals to resource patches
                for (int i = 0; i < population.size(); ++i)
                    foodPatches[i].push_back(i);
                
                // 3 - Asymetric competition (Raph 12/12)
                // For each patch...
                for (int p = 0; p < foodPatches.size(); ++p) {
                    
                    // If that patch is occupied by more than one indiv, then competition happens
                    if (foodPatches[p].size() > 1) {
                        
                        // Record the sizes of the individuals competing for a patch
                        vector<double> competingSizes(foodPatches[p].size());
                        
                        for (int j = 0; j < competingSizes.size(); ++j)
                            competingSizes[j] = population[foodPatches[p][j]].size;
                        
                        // Draw the outcome of competition
                        discrete_distribution<int> competitionEvent(competingSizes.begin(), competingSizes.end());
                        const int competitionOutcome = competitionEvent(rng);
                        int iWinner = foodPatches[p][competitionOutcome];
                        
                        // The winner receives the food
                        for (int j = 0; j < competingSizes.size(); ++j)
                            population[foodPatches[p][j]].hasFood = foodPatches[p][j] == iWinner ? true : false;
                    }
                    
                    // If only one individual, then it takes the food
                    else if (foodPatches[p].size() == 1) {
                        population[foodPatches[p][0]].hasFood = true;
                    }
                }
                
                */
                
                // 3 - Reproductive step of preys
                
                 // Identify current breeding individuals
                 int iCurrentPop = population.size();
                cout << "Gen" << t << " population size = " << iCurrentPop << endl;
                 vector <ind> populationNew; // <THEO 12/12>

                 for (int i = 0; i < iCurrentPop; ++i) {
                     // increment ageing <THEO 12/12>
                     assert( !(population[i].age < 0) && !(population[i].age > deathAge) );
                     ++population[i].age;
                     //cout << "Adult   of size " << population[i].size << " and " << population[i].age << " gen old"<< endl;
                     
                     // Add breeder to the next gen population if not too old  // <THEO 12/12>
                     if (population[i].age <= deathAge)
                         populationNew.push_back(population[i]);
                     
                     // Produce a number of offspring based on size // <THEO 12/12>
                     population[i].hasFood = true;
                     if (population[i].hasFood) {
                     
                         // expense food on offspring production
                         population[i].hasFood = false;
                 
                         int iLitterSize = getNbOffspring(population[i].size);
                 
                         for (int iOffspring = 0; iOffspring < iLitterSize; ++iOffspring) {
                     
                             // Create a new individual that is a clone of its parent with age 0
                             ind newborn = population[i];
                             newborn.age = 0;
                             
                             // Draw a mutation event // <THEO 12/12>
                             if (mutationEvent(rng)) {
                                 //cout << "<MUTATION> ";
                                 double mutationStep;
                                 do {
                                     mutationStep = mutation(rng);
                                 } while (newborn.size + mutationStep <= 0.1);  // <THEO 14/12> constrain mutation to min size
                                 newborn.size += mutationStep;
                             }
                             //cout << "Newborn of size " << newborn.size << " and " << newborn.age << " gen old" << endl;
                             // Add new individual to the next gen population
                             populationNew.push_back(newborn);  // <THEO 12/12>
                         }
                     }
                 // else nothing happens, no food no baby (or babies but they die right away from starvation)
                     
                 }
                cout << "Gen" << t << " pop size before reproduction & death = " << iCurrentPop << endl;
                cout << "Gen" << t << " pop size after  reproduction & death = " << populationNew.size() << endl;
                
                population = populationNew;
                
                if (population.empty()){
                    cerr << "Generation " << t << ": population went extinct\n";
                    exit(EXIT_SUCCESS);
                }
                
                // 4 - Reproductive step of predators
                
                
                
            } // end of loop through time steps
            
        }
        catch (exception &error) {
            cerr << "Error: " << error.what() << endl;
            exit(1);
        }
        
        
        return 0;
    }
