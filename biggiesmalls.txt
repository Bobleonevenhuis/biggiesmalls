# include <vector>
# include <chrono>
# include <random>
# include <iostream>
# include <cassert>
# include <exception>
# include <cmath>
# include <string>
# include <cstdlib>
# include <fstream>
# include <sstream>

using namespace std;

// RANDOM NUMBER GENERATOR

mt19937_64 rng;

// CLASSES

// Class of individuals
struct ind {
	double  size = 0;
	bool    hasFood = false;
	int     age = 0;
	bool    isEaten = false;
};

// ACCESSORY FUNCTION

// Function to shuffle a vector
void shuffleVector(vector<ind> &vec, mt19937_64 &rng) {

	// For each position in the vector (starting from the end)...
	for (int i = vec.size() - 1; i > 0; --i) {

		// Create a distribution of random numbers between 0 and i
		uniform_int_distribution<int> randomNumber(0, i);

		// Draw a random position placed before it in the vector
		int j = randomNumber(rng);
		assert(j <= i);
		assert(j >= 0);

		// Swap the two positions
		ind tmp = vec[i];
		vec[i] = vec[j];
		vec[j] = tmp;

	}

}

// Function to determine the litter size of an individual
int getNbOffspring(const double &parentSize, const double &beta, const int &growth0, const double &epsilon) {
	double meanNbOffspring = (beta / parentSize + (1.0 - beta) * growth0) * epsilon;
	poisson_distribution<int> offspringDistribution(meanNbOffspring);
	int nbOffspring = offspringDistribution(rng);
	if (nbOffspring > 10)
		nbOffspring = 10;
	return nbOffspring;

}

// Function to read parameters from an input file
vector<double> readParameters(const string &inputfile) {

	ifstream ifs(inputfile.c_str());
	if (!ifs.is_open()) {
		throw runtime_error("unable to open input file");
		exit(1);
	}
	clog << "reading parameter from file" << inputfile << endl;

	double par;
	vector<double> vecpar;

	while (!ifs.eof()) {
		ifs >> par;
		if (ifs.fail()) {
			ifs.clear();
			ifs.ignore();
		}
		else {
			vecpar.push_back(par);
		}
	}

	return vecpar;

}


// MAIN FUNCTION

int main(int argc, char* argv[]) {


	try {

		// DEFAULT PARAMETER VALUES

		// Constant parameters
		const int maxSampling = 1000; // Max number of times for resampling a body size if the result was negative or too low
		const double minBodySize = 0.000001; // Minimum body size allowed
		const double epsilon = 1.0; // Scaling parameter for offspring reproduction

		// Parameters that may be overwritten if command-line arguments are provided
		int N = 100; // Initial population size
		int S = 100; // Island size (number of patches on the island)
		int maxTime = 100; // Max duration of the simulation
		int deathAge = 0; // Lifespan of the preys (generations)
		int deathAgePredators = 2; // Lifespan of the predators (generations)
		int initPredatorDensity = 5; // Initial popultion size of the predators
		int growth0 = 1; // Basal number of offspring of the preys when reproduction is size independent
		double meanSize0 = 2.0; // Mean body size in the mainland (source) population
		double stdSize0 = 3.0; // Standard deviation of body size on the mainland
		double killConversion = 2.0; // Proportion of a killed prey that produces predator offspring
		double mutationalVariance = 0.1; // Standard deviation of the normal distribution describing mutational effects
		double mutationRate = 0.5; // Mutation rate (generation-1)

		const double alpha0 = 1.0, beta0 = 1.0, gamma0 = 1.0; // default values of parameters of dependency of ecological forces on body size

		// PASSING ARGUMENTS

		vector<double> alphas; // Parameter tuning the dependency of competition on body size
		vector<double> betas; // Parameter tuning the dependency of reproduction on body size
		vector<double> gammas; // Parameter tuning the dependency of predation on body size		

		string inputFileName;

		vector<bool> isProvided(3);

		if (argc > 1) {

			for (int i = 1; i < argc; ) {

				string argument = string(argv[i]);
				istringstream ss(argv[i + 1]);

				if (argument == "-alpha") isProvided[0] = true;
				else if (argument == "-beta") isProvided[1] = true;
				else if (argument == "-gamma") isProvided[2] = true;

				int iArg; // if argument is an integer
				double dArg; // if argument is a double
				string sArg; // if argument is a string

				//if (!(ss >> x))
				//cerr << "Invalid number " << argv[1] << '\n';

				if (ss >> iArg) {
					int iValue = atoi(argv[i + 1]);
					if (argument == "-N") N = iValue;
					else if (argument == "-S") S = iValue;
					else if (argument == "-maxTime") maxTime = iValue;
					else if (argument == "-deathAge") deathAge = iValue;
					else if (argument == "-deathAgePredators") deathAge = iValue;
					else if (argument == "-initPredatorDensity") initPredatorDensity = iValue;
					else if (argument == "-growth0") growth0 = iValue;

				}
				else if (ss >> dArg) {
					double dValue = atof(argv[i + 1]);
					if (argument == "-meanSize0") meanSize0 = dValue;
					else if (argument == "-stdSize0") stdSize0 = dValue;
					else if (argument == "-killConversion") killConversion = dValue;
					else if (argument == "-mutationalVariance") mutationalVariance = dValue;
					else if (argument == "-mutationRate") mutationRate = dValue;

					else if (argument == "-alpha") alphas.push_back(dValue);
					else if (argument == "-beta") betas.push_back(dValue);
					else if (argument == "-gamma") gammas.push_back(dValue);
				}
				else if (ss >> sArg) {
					inputFileName = string(argv[i + 1]);
					if (argument == "-alpha") alphas = readParameters(inputFileName);
					else if (argument == "-beta") betas = readParameters(inputFileName);
					else if (argument == "-gamma") gammas = readParameters(inputFileName);
				}

			} // end of loop through arguments
		} // end of if more than one argument

		// Set default values if parameters were not provided
		if (!isProvided[0]) alphas.push_back(alpha0);
		if (!isProvided[1]) betas.push_back(beta0);
		if (!isProvided[2]) gammas.push_back(gamma0);

		// Probability distributions
		bernoulli_distribution mutationEvent(mutationRate); // Distribution in which to draw mutation events
		normal_distribution <double> bodySizeDistribution(meanSize0, stdSize0); // Distribution in which to draw body sizes
		normal_distribution <double> mutation(0.0, mutationalVariance); // Distribution in which to draw mutational effects
		// Note: mutation std = 0.5 allows to go from values around 3.0 at gen0 to ~15.0 at gen1000

		// START SIMULATION

		for (int a = 0; a < alphas.size(); ++a) {

			const double alpha = alphas[a];

			for (int b = 0; b < betas.size(); ++b) {

				const double beta = betas[b];

				for (int g = 0; g < gammas.size(); ++g) {

					const double gamma = gammas[g];

					if (meanSize0 <= 0.0)
						throw runtime_error("meanSize cannot be zero or negative");
					if (stdSize0 <= 0.0)
						throw runtime_error("stdSize cannot be zero or negative");
					if (minBodySize < 0.0)
						throw runtime_error("minimal body size cannot be negative");

					// Set random seed
					auto tp = chrono::high_resolution_clock::now();
					unsigned seed = static_cast<unsigned>(tp.time_since_epoch().count());
					rng.seed(seed);

					// Declare an initial population of N individuals
					vector <ind> population(N);
					assert(population.size() == N);

					// Initialize size of individuals from normal distribution with given mean and standard deviation
					for (int i = 0; i < population.size(); ++i) {
						int a = 0;
						do {
							population[i].size = bodySizeDistribution(rng);
							++a;
							// If the size of an individual is too small, redraw it (the normal distribution is truncated in zero)
							// but not too many times
						} while (population[i].size <= minBodySize && a < maxSampling);
						if (population[i].size < minBodySize)
							throw runtime_error("negative values of body size were generated");
						//cout << population[i].size << ' ';
					}
					//cout << endl;

					// Initialize predator population
					if (initPredatorDensity < 0)
						throw runtime_error("initial density of predators cannot be negative");
					if (deathAgePredators <= 0)
						throw runtime_error("death rate of predators must be at least one year");

					int nPredators = initPredatorDensity;
					bool isExtinctPredator = initPredatorDensity == 0 ? true : false;
					vector<int> birthRecord(deathAgePredators); // vector recording number of predator born in the last <predator lifespan> years
					assert(birthRecord.size() == deathAgePredators);

					if (initPredatorDensity == 0)
						cout << "Simulation with no predators" << endl;


					// Generation step loop
					for (int t = 1; t <= maxTime; ++t) {

						//cout << t << endl;

						// Check if there still are individuals in the population
						if (population.empty()) {
							cerr << "Generation " << t << ": population went extinct\n";
							exit(EXIT_SUCCESS);
						}


						// Declare the number of food patches available as defined by island surface
						// foodPatches is a vector of subvectors: each subvector says which individuals are on the patch
						vector<vector<int> > foodPatches(S);
						assert(foodPatches.size() == S);



						// (Re)Shuffling the population vector
						shuffleVector(population, rng);


						// 1 - ASSIGNING INDIVIDUALS TO FOOD PATCHES
						for (int i = 0; i < population.size(); ++i) {
							foodPatches[i % S].push_back(i);
						}



						// 2 - PREDATION

						// Vector of survivors of predation
						vector<ind> survivors;

						int nKills = 0;
						if (!isExtinctPredator) {

							// Every predator picks a patch at random, and if preys are present, eats one
							for (int j = 0; j < nPredators; ++j) {

								// Pick a patch
								uniform_int_distribution<int> pickPatch(0, S - 1);
								int patch = pickPatch(rng);
								assert(patch >= 0 && patch <= S - 1);

								int prey;

								// If there is one individual on that patch, eat it
								if (foodPatches[patch].size() >= 1) {
									if (foodPatches[patch].size() == 1)
										prey = 0;

									// If there are more...
									else if (foodPatches[patch].size() > 1) {

										// Probabilities of each individual in the patch to be caught, depending on body size(or not if gamma = 0)
										vector<double> probCatch(foodPatches[patch].size());
										assert(probCatch.size() == foodPatches[patch].size());
										double sum = 0.0;
										for (int i = 0; i < foodPatches[patch].size(); ++i) {
											probCatch[i] = pow(population[foodPatches[patch][i]].size, exp(gamma) - 1.0);
											sum += probCatch[i];
										}
										for (int i = 0; i < foodPatches[patch].size(); ++i) {
											probCatch[i] /= sum;
											assert(probCatch[i] >= 0.0 && probCatch[i] <= 1.0);
										}

										// Pick a random prey
										discrete_distribution<int> pickPrey(probCatch.begin(), probCatch.end());
										prey = pickPrey(rng);
										assert(prey >= 0 && prey < foodPatches[patch].size());
									}

									// Prey is eaten
									population[foodPatches[patch][prey]].isEaten = true;

									// Prey is removed from the patch
									vector<int> patchSurvivors;
									for (int i = 0; i < foodPatches[patch].size(); ++i)
										if (i != prey)
											patchSurvivors.push_back(i);
									assert(patchSurvivors.size() == foodPatches[patch].size() - 1);

									foodPatches[patch] = patchSurvivors;

									// Update the number of kills
									++nKills;
								}

							} // end of loop through predators

							  // Population will be updated later (otherwise competition step bugs)

						} // end of predation




						  // 3 - ASYMETRIC COMPETITION
						  // For each patch...
						for (int p = 0; p < foodPatches.size(); ++p) {

							// If that patch is occupied by more than one indiv, then competition happens
							if (foodPatches[p].size() > 1) {

								// Probabilities of each individual in the patch to win, depending on body size(or not if alpha = 0)
								vector<double> probWin(foodPatches[p].size());
								assert(probWin.size() == foodPatches[p].size());
								double sum = 0.0;
								for (int i = 0; i < foodPatches[p].size(); ++i) {
									probWin[i] = pow(population[foodPatches[p][i]].size, exp(alpha) - 1.0);
									sum += probWin[i];
								}
								for (int i = 0; i < foodPatches[p].size(); ++i) {
									probWin[i] /= sum;
									assert(probWin[i] >= 0.0 && probWin[i] <= 1.0);
								}

								// Draw the outcome of competition
								discrete_distribution<int> competitionEvent(probWin.begin(), probWin.end());
								const int competitionOutcome = competitionEvent(rng);
								int iWinner = foodPatches[p][competitionOutcome];

								// The winner receives the food
								for (int j = 0; j < foodPatches[p].size(); ++j)
									population[foodPatches[p][j]].hasFood = foodPatches[p][j] == iWinner ? true : false;

							}

							// If only one individual, then it takes the food
							else if (foodPatches[p].size() == 1) {
								population[foodPatches[p][0]].hasFood = true;
							}

						}


						// Who survived?
						for (int i = 0; i < population.size(); ++i) {
							if (!population[i].isEaten)
								survivors.push_back(population[i]);
						}
						assert(survivors.size() <= population.size());

						// Only survivors of predation remain in the population
						population = survivors;


						// 4 - REPRODUCTION OF PREYS

						// Identify current breeding individuals
						int iCurrentPop = population.size();
						//cout << "Gen" << t << " population size = " << iCurrentPop << endl;
						vector <ind> populationNew; // <THEO 12/12>

						for (int i = 0; i < iCurrentPop; ++i) {
							// increment ageing <THEO 12/12>
							assert(!(population[i].age < 0) && !(population[i].age > deathAge));
							++population[i].age;
							//cout << "Adult   of size " << population[i].size << " and " << population[i].age << " gen old" << endl;

							// Add breeder to the next gen population if not too old  // <THEO 12/12>
							if (population[i].age < deathAge)
								populationNew.push_back(population[i]);

							// Produce a number of offspring based on size // <THEO 12/12>
							population[i].hasFood = true;
							if (population[i].hasFood) {

								// expense food on offspring production
								population[i].hasFood = false;

								int iLitterSize = getNbOffspring(population[i].size, beta, growth0, epsilon);

								for (int iOffspring = 0; iOffspring < iLitterSize; ++iOffspring) {

									// Create a new individual that is a clone of its parent with age 0
									ind newborn = population[i];
									newborn.age = 0;

									// Draw a mutation event // <THEO 12/12>
									if (mutationEvent(rng)) {
										//cout << "<MUTATION> ";
										double mutationStep;
										do {
											mutationStep = mutation(rng);
										} while (newborn.size + mutationStep < minBodySize); // constrain mutation to min size
										newborn.size += mutationStep;
									}
									//cout << "Newborn of size " << newborn.size << " and " << newborn.age << " gen old" << endl;
									// Add new individual to the next gen population
									populationNew.push_back(newborn);  // <THEO 12/12>
								}
							}
							// else nothing happens, no food no baby (or babies but they die right away from starvation)

						}
						//cout << "Gen" << t << " pop size before reproduction & death = " << iCurrentPop << endl;
						//cout << "Gen" << t << " pop size after  reproduction & death = " << populationNew.size() << endl;

						population = populationNew;

						if (population.empty()) {
							cerr << "Generation " << t << ": population went extinct\n";
							exit(EXIT_SUCCESS);
						}


						// 5 - REPRODUCTION AND DEATH OF PREDATORS

						if (!isExtinctPredator) {

							// Reproduction
							int nBabyPredators = floor(nKills * killConversion);
							assert(nBabyPredators >= 0);
							//cout << nPredators << " + " << nBabyPredators << " = ";
							nPredators += nBabyPredators;
							//cout << nPredators << endl;

							// If time step < predator lifespan record births every year
							if (t < deathAgePredators)
								birthRecord[t] = nPredators;
							else {

								// Otherwise, update birth records
								for (int j = 0; j < birthRecord.size(); ++j)
									birthRecord[j] = j == deathAgePredators - 1 ? nBabyPredators : birthRecord[j + 1];

								// And mortality happens
								nPredators -= birthRecord[0]; // all predators who were born <lifespan> years ago die now

							}

						}



						// Warning if predators go extinct
						if (nPredators <= 0 && !isExtinctPredator) {
							cerr << "Generation " << t << ": predators went extinct\n";
							isExtinctPredator = true;
						}

						cout << "Time " << t << ": " << population.size() << " preys and " << nPredators << " predators" << endl;

					} // end of loop through time steps

				}
			}
		}

		

	}
	catch (exception &error) {
		cerr << "Error: " << error.what() << endl;
		exit(1);
	}


	return 0;
}
