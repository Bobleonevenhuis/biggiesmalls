# include <vector>
# include <chrono>
# include <random>
# include <iostream>
# include <cassert>
# include <exception>

using namespace std;

// GLOBAL CONSTANTS

// declare parameters
const int		maxAge = 0;
const int       N = 1000;
const int       S = 100; // m^2
const int       maxTime = 1;
const double meanSize = 2.0; //added by Raph 12/12
const double stdSize = 3.0; //added by Raph 12/12
const double precision = 0.000001; // added by Raph 12/12, precision threshold to say if a number is equal to zero
const int maxSampling = 1000; // cannot resample the size of an individual more than this number if the size happen to be too small
bernoulli_distribution mutationEvent(0.05);
normal_distribution<double> bodySizeDistribution(meanSize, stdSize); //added by Raph 12/12

// migration rate ?

// RANDOM NUMBER GENERATOR

// declare rng
mt19937_64 rng;

// CLASSES

// declare predators

// class of individuals
struct ind {
	double  size;
	bool    hasFood = false;
	int     age = 0;
};

// ACCESSORY FUNCTION

// Function to shuffle a vector (added by Raph 12/12)
void shuffleVector(vector<ind> &vec, mt19937_64 &rng) {

	// For each position in the vector (starting from the end)...
	for (int i = vec.size() - 1; i > 0; --i) {

		// Create a distribution of random numbers between 0 and i
		uniform_int_distribution<int> randomNumber(0, i);

		// Draw a random position placed before it in the vector
		int j = randomNumber(rng);
		assert(j <= i);
		assert(j >= 0);

		// Swap the two positions
		ind tmp = vec[i];
		vec[i] = vec[j];
		vec[j] = tmp;

	}

}

// MAIN FUNCTION

int main() {

	try {

		// Raph 12/12 security check
		if (meanSize <= 0.0)
			throw runtime_error("meanSize cannot be zero or negative");
		if (stdSize <= 0.0)
			throw runtime_error("stdSize cannot be zero or negative");
		if (precision < 0.0)
			throw runtime_error("precision cannot be zero");

		// set random seed
		auto tp = chrono::high_resolution_clock::now();
		unsigned seed = static_cast<unsigned>(tp.time_since_epoch().count());
		rng.seed(seed);

		// Declare an initial population of N individuals
		vector <ind> population(N);
		assert(population.size() == N);

		vector <int> crematorium;

		// Initialize the size of the individuals from a normal distribution with a given mean and standard deviation (Raph 12/12)
		for (int i = 0; i < population.size(); ++i) {
			int a = 0;
			do {

				population[i].size = bodySizeDistribution(rng);
				++a;

				// If the size of an individual is too small, redraw it (the normal distribution is truncated in zero)
				// but not too many times
			} while (population[i].size <= precision && a < maxSampling);
			if (population[i].size < precision)
				throw runtime_error("negative values of body size were generated");
			//cout << population[i].size << ' ';
		}
		//cout << endl;

		

		// generation step loop
		for(int t = 0; t < maxTime || population.size() > 1; ++t) {

			// Declare the number of food patches available as defined by island surface
			// foodPatches is a vector of subvectors: each subvector says which individuals are on the patch
			vector <vector<int> > foodPatches(S);
			assert(foodPatches.size() == S);

			// 1 - Predation
			// for each predator {
			//      for x preys {
			//          pick a random prey based on its weight
			//          add preys resource stock to predator stock
			//          ¡ remove dead preys ! crematorium.push_back(i) + removal

			//      }
			// }

			// (Re)Shuffling the population vector
			shuffleVector(population, rng);
			
			// 2 - Assign individuals to resource patches
			for (int i = 0; i < population.size(); ++i)
				foodPatches[i].push_back(i);
		

			// 3 - Asymetric competition (Raph 12/12)
			// For each patch...
			for (int p = 0; p < foodPatches.size(); ++p) {

				// If that patch is occupied by more than one indiv, then competition happens
				if (foodPatches[p].size() > 1) {

					// Record the sizes of the individuals competing for a patch
					vector<double> competingSizes(foodPatches[p].size()); 
					
					for (int j = 0; j < competingSizes.size(); ++j)
						competingSizes[j] = population[foodPatches[p][j]].size;

					// Draw the outcome of competition
					discrete_distribution<int> competitionEvent(competingSizes.begin(), competingSizes.end());
					const int competitionOutcome = competitionEvent(rng); 
					int iWinner = foodPatches[p][competitionOutcome];

					// The winner receives the food
					for (int j = 0; j < competingSizes.size(); ++j)
						population[foodPatches[p][j]].hasFood = foodPatches[p][j] == iWinner ? true : false;
				}

				// If only one individual, then it takes the food
				else if (foodPatches[p].size() == 1) {
					population[foodPatches[p][0]].hasFood = true;
				}
			}



		// 3 - Reproductive step of preys

		/*
		// Identify current breeding individuals
		int iNbBreeders = population.size();

		for (int i = 0; i < iNbBreeders; ++i) {
		if (population[i].hasFood) {       // has it food ?
		population[i].hasFood = false; // now it doesn't

		// produce a number of offspring based on size
		int iLitterSize = (100 / population[i].size);

		for (int iOffspring = 0; iOffspring < iLitterSize; ++iOffspring) {
		// Create a new individual that is a clone of its parent with age 0
		ind newborn = population[i];
		newborn.age = 0;
		// Draw a mutation event
		if (mutationEvent(rng)) {
		normal_distribution<double> mutation(0.0, 2.0);
		newborn.size += mutation(rng);
		}
		// Add new individual to the population
		population.push_back(newborn);
		}
		// Breeders grow 1 gen older
		if (maxAge)
			++population[i].age;             // happy birthday EVERYONE BIG PARTY
		if (population[i].age >= maxAge)
		crematorium.push_back(i); // not you grandpa
		}
		// else nothing happens, no food no baby (or babies but they die right away from starvation)
		}
		*/



		// 4 - Reproductive step of predators

		/*
		// 5 - Remove dead individuals
		for (int i = 0; i < crematorium.size(); ++i) {
		population[crematorium[i]] = population.back();
		population.pop_back();
		}
		*/



		} // end of loop through time steps


	}
	catch (exception &error) {
		cerr << "Error: " << error.what() << endl;
		exit(1);
	}

	

	return 0;
}